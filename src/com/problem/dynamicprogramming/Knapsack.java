package com.problem.dynamicprogramming;

/**
 * This is 0/1 knapsack problem i.e splitting of individual items is not allowed.
 * In this case, we can use an item only once and still maximize the value.
 *
 * Example: Given weights and values of n items, put these items in a knapsack of capacity W
 * to get the maximum total value in the knapsack.
 * In other words, given two integer arrays val[0..n-1] and wt[0..n-1] which represent values
 * and weights associated with n items respectively.
 * Also given an integer W which represents knapsack capacity,
 * find out the maximum value subset of val[] such that sum of
 * the weights of this subset is smaller than or equal to W.
 * You cannot break an item, either pick the complete item, or donâ€™t pick it (0-1 property).
 *
 */
public class Knapsack {

    public int maximizeValue(int W, int[] weight, int[] value) {
        // create a dp array of size weight.length + 1 and W + 1. Extra 1 is added to handle when no item
        // is present and limit of W is 0
        int[][] dp = new int[weight.length + 1][W + 1];

        // iteration starts from 1 because i = 0 represents no item is present and j = 0 represents max weight
        // limit is 0
        for(int i = 1; i <= weight.length; i++) {
            for(int j = 1; j <= W; j++) {
                // if weight of ith item is less than or equal to j (maximum weight allowed)
                if(weight[i - 1] <= j) {
                    // you can either select ith item and add pending allowed weight by backtracking
                    // ex. if we want max weight of 7 and we are selecting item which has weight 5 then
                    // get 7 - 5 = 2 where 2 represents max allowed weight which is already calculated in
                    // the past. Also, make sure that we are picking ith item only once.
                    //                            OR
                    // you can ignore ith item and pick the maximum value generated by prev items
                    dp[i][j] = Math.max(dp[i - 1][j], value[i - 1] + dp[i - 1][j - weight[i - 1]]);
                } else {
                    // if the weight of ith item is greater than maximum allowed weight pick the
                    // maximum value generated by prev items.
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        // return the calculated final item
        return dp[weight.length][W];
    }
}
